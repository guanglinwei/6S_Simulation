import argparse
import os
import shutil
import re

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Edit the Makefile and main.f of the 6S code to include the target .f files generated by srf_txt_to_fortran.py.")

    parser.add_argument(
        "f_files", 
        nargs="*",
        help="Names of Fortran files."
    )
    parser.add_argument(
        '-r', '--recursive',
        dest='recursive_dir',
        nargs='?',
        const='./f_out/', 
        type=str,       
        help='Directory to read Fortran files from.'
    )
    parser.add_argument(
        '-o', '--override',
        dest='override',
        default=False,
        action='store_true',
        help='Override existing .f files with output. Not recommended.'
    )
    parser.add_argument(
        '-i', '--in-dir',
        dest='in_dir',
        default='./base_fortran/',
        help='Directory of unmodified 6S code. Defaults to "./base_fortran/"'
    )
    parser.add_argument(
        '-d', '--out-dir',
        dest='out_dir',
        default='./fortran/',
        help='Directory to output Fortran files. Defaults to "./fortran/"'
    )
    parser.add_argument(
        '--keep-writes',
        dest='keep_writes',
        default=False,
        action='store_true',
        help='Skip removing the text output portion of 6S simulation. Only set this flag if you need the simulation outputs as .txt files. Defaults to False.'
    )

    args = parser.parse_args()

    # Ensure fortran directories exist and are different
    if not os.path.isdir(args.out_dir):
        parser.error(f'{args.out_dir} is not a valid directory or does not exist.')
        
    if not os.path.isdir(args.in_dir):
        parser.error(f'{args.in_dir} is not a valid directory or does not exist.')
        
    if args.out_dir == args.in_dir:
        parser.error('Input and output directories cannot be the same.')
        
    # Ensure fortran output directory is empty and copy over from input directory
    if len(os.listdir(args.out_dir)) != 0:
        if not args.override:
            parser.error(f'Directory {args.out_dir} is not empty. Please use the --override option if you wish to clear it.')
        user_input = input(f'Output directory will be cleared: {args.out_dir}. Do you want to continue? (y/n): ').strip().lower()
        if user_input != 'y':
            quit()
        shutil.rmtree(args.out_dir)
        shutil.copytree(args.in_dir, args.out_dir)
    
    if not args.f_files and not args.recursive_dir:
        parser.error('Must either provide list of .f files or a directory with -r <directory>. Use -h for more info.')
    
    if args.f_files and args.recursive_dir:
        print('Both file list and directory are provided. Ignoring the directory and only using provided .f files.')
        
    print('Please ensure your input fortran directory contains the unmodified 6SV2.1 code.')
    print('Processing...')
    
    f_files = []
    subroutine_names = []
    if args.f_files:
        # Get all the generated fortran file paths
        for f_name in args.f_files:
            if f_name[-2:] != '.f':
                parser.error(f'{f_name} does not end with .f.')
            # if filename has no path, assume in out_dir
            # otherwise copy it into out_dir
            f_basename = os.path.basename(f_name)
            target_path = os.path.join(args.out_dir, f_basename)
            if not args.override and os.path.exists(target_path):
                parser.error(f'{target_path} already exists. Set the -o flag to override it. ONLY DO SO IF IT IS A USER-GENERATED .f FILE.')
            if not f_basename == f_name or os.path.exists(f_basename): 
                print(f'Copying {f_basename} into {args.out_dir}')
                shutil.copyfile(f_name, target_path)
            f_files.append(target_path)
            
            if not os.path.exists(target_path):
                parser.error(f'{target_path} does not exist.')
                
            with open(target_path, 'r') as f_file:
                for line in f_file.readlines():
                    if (match := re.match(r'\s*subroutine (\w*)\(.*', line)):
                        subroutine_name = match.group(1)
                        subroutine_names.append(subroutine_name)
    else:
        if args.recursive_dir == args.out_dir:
            parser.error('Directory to read .f files from cannot be the same as the 6S code directory.')
            
        for filename in os.scandir(args.recursive_dir):
            if filename.is_file():
                target_path = os.path.join(args.out_dir, filename.name)
                if not args.override and os.path.exists(target_path):
                    parser.error(f'{target_path} already exists. Set the -o flag to override it. ONLY DO SO IF IT IS A USER-GENERATED .f FILE.')
            
                print(f'Copying {filename.path} into {args.out_dir}')
                shutil.copyfile(filename.path, target_path)
                f_files.append(target_path)
                
                with open(target_path, 'r') as f_file:
                    for line in f_file.readlines():
                        if (match := re.match(r'\s*subroutine (\w*)\(.*', line)):
                            subroutine_name = match.group(1)
                            subroutine_names.append(subroutine_name)
    
    print('Found subroutines:', ', '.join(subroutine_names))
    print('Attempting to edit Makefile and main.f of 6S code to include newly generated .f file.')
    
    in_makefile_path = os.path.join(args.in_dir, 'Makefile')
    out_makefile_path = os.path.join(args.out_dir, 'Makefile')
    if not os.path.exists(in_makefile_path) or not os.path.isfile(in_makefile_path):
        parser.error(f'Could not find Makefile: {in_makefile_path} is not a path or does not exist.')
    if not os.path.exists(out_makefile_path) or not os.path.isfile(out_makefile_path):
        parser.error(f'Could not find Makefile: {out_makefile_path} is not a path or does not exist.')
    
    replaced_extra_cflags = False
    with open(in_makefile_path, 'r') as f:
        mf_lines = f.readlines()
        extra_obj_line_index = -1
        sixs_build_start_line_index = -1
        for i, line in enumerate(mf_lines):
            if line.startswith('EXTRA'):
                if replaced_extra_cflags:
                    mf_lines[i] = ''
                else:
                    replaced_extra_cflags = True
                    mf_lines[i] = 'EXTRA	= -g -ffixed-line-length-132 -O -ffixed-line-length-132 -std=legacy -ffixed-line-length-none\n'
                    print('Added additional cflags to Makefile')
            elif line.startswith('OBJECTSEXTRA='):
                extra_obj_line_index = i
            elif line.startswith('sixs:'):
                sixs_build_start_line_index = i
                
        if sixs_build_start_line_index == -1:
            raise Exception(f'{in_makefile_path} is not a valid Makefile. ' + \
                'Build instructions for target sixs does not exist. ' + \
                'Are you sure you downloaded the correct 6S code (6SV2.1)?')
            
        if not replaced_extra_cflags:
            raise Exception(f'{in_makefile_path} is not a valid Makefile. ' + \
                'Line for extra cflags (EXTRA = ...)does not exist. ' + \
                'Are you sure you downloaded the correct 6S code (6SV2.1)?')
            
        extra_build_objs = [os.path.basename(path).split('.')[0] + '.o' for path in f_files]
        extra_build_objs_str = 'OBJECTSEXTRA= ' + (' '.join(extra_build_objs)) + '\n'
        
        if extra_obj_line_index == -1:
            mf_lines.insert(sixs_build_start_line_index, extra_build_objs_str)
            mf_lines.insert(sixs_build_start_line_index + 1, '\n')
            sixs_build_start_line_index += 2
        else:
            mf_lines[extra_obj_line_index] = extra_build_objs_str
            
        try:
            mf_lines[sixs_build_start_line_index].index('$(OBJECTSEXTRA)')
        except ValueError:
            mf_lines[sixs_build_start_line_index] = f'{mf_lines[sixs_build_start_line_index][:-1]} $(OBJECTSEXTRA)\n'
            
        try:
            mf_lines[sixs_build_start_line_index+1].index('$(OBJECTSEXTRA)')
        except ValueError:
            before_o, after_o = mf_lines[sixs_build_start_line_index+1].split('-o')
            mf_lines[sixs_build_start_line_index+1] = f'{before_o}$(OBJECTSEXTRA) -o{after_o}'
            
        try:
            mf_lines[sixs_build_start_line_index+2].index('$(OBJECTSEXTRA)')
        except ValueError:
            before_o, after_o = mf_lines[sixs_build_start_line_index+2].split('-o')
            mf_lines[sixs_build_start_line_index+2] = f'{before_o}$(OBJECTSEXTRA) -o{after_o}'
            
    with open(out_makefile_path, 'w') as f:
        f.write(''.join(mf_lines))
        print(f'Successfully wrote Makefile to {out_makefile_path}')
        
    # Edit main.f
    in_main_path = os.path.join(args.in_dir, 'main.f')
    out_main_path = os.path.join(args.out_dir, 'main.f')
    with open(in_main_path, 'r')  as f:
        main_lines = f.readlines()
        
        # Comment out unnecessary writes
        if not args.keep_writes:
            start_index = 2375
            for i, line in enumerate(main_lines[start_index:2400]):
                if line.strip().startswith('write(6,*)') or line.strip().startswith('Write(6,*)'):
                    main_lines[start_index+i] = 'c ' + line
            
            found_geom_conditions = False    
            for i, line in enumerate(main_lines):
                if line.strip() == 'c ---- geometrical conditions ----':
                    found_geom_conditions = True
                if found_geom_conditions:
                    if re.match(r'^c\*+c$', line.strip()):
                        break
                    main_lines[i] = 'c ' + main_lines[i]
                    
                    
            print('Removed text file output portion of 6S.')
            
            for i, line in enumerate(main_lines):
                if re.match(r'c.*print of final results.*', line.strip()):
                    with open('./reformatted_main_end_block.f', 'r') as new_main_f:
                        main_lines = main_lines[:i] + new_main_f.readlines()
                    break
                
            print('Rewrote output block.')
            
        # Call the new subroutines
        found_goto_entry_block = False
        goto_entry_block_insert_index = -1
        subroutine_call_insert_index = -1
        count_commas = True
        comma_count = 0
        for i, line in enumerate(main_lines):
            if re.match(r'\s*18 goto.*', line):
                found_goto_entry_block = i
                comma_count += line.count(',')
            if found_goto_entry_block:
                if re.match(r'.*19 iinf.*', line):
                    subroutine_call_insert_index = i
                    break
                
                if count_commas:
                    comma_count += line.count(',')
                
                match = re.match(r'(.*)\),iwave', line)
                if not match:
                    continue
                main_lines[i] = match.group(1) + ',\n'
                goto_entry_block_insert_index = i + 1
                count_commas = False
        
        iwave_modifier = comma_count - 1  
        for i, subroutine in enumerate(subroutine_names):
            subroutine_goto = f'99{str(i).zfill(2)}'
            goto_line = f'     s      {subroutine_goto}'
            if i == len(subroutine_names) - 1:
                goto_line += '),iwave\n'
            else: 
                goto_line += ',\n'
                
            main_lines.insert(goto_entry_block_insert_index, goto_line)
            goto_entry_block_insert_index += 1
            subroutine_call_insert_index += 1
            
            call_subroutine_line = f' {subroutine_goto} call {subroutine}(iwave-{iwave_modifier})\n'
            main_lines.insert(subroutine_call_insert_index, call_subroutine_line)
            main_lines.insert(subroutine_call_insert_index + 1, '      goto 19\n')
            iwave_modifier += 1
            subroutine_call_insert_index += 2
            
            
            
    with open(out_main_path, 'w') as f:
        f.write(''.join(main_lines))
        print(f'Successfully wrote main.f to {out_main_path}')