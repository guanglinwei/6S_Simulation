import argparse
import os
import shutil

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Edit the Makefile and main.f of the 6S code to include the target .f files generated by srf_txt_to_fortran.py.")

    parser.add_argument(
        "f_files", 
        nargs="*",
        help="Names of Fortran files."
    )
    parser.add_argument(
        '-r', '--recursive',
        dest='recursive_dir',
        nargs='?',
        const='./f_out/', 
        type=str,       
        help='Directory to read Fortran files from.'
    )
    parser.add_argument(
        '-o', '--override',
        dest='override',
        default=False,
        action='store_true',
        help='Override existing .f files with output. Not recommended.'
    )
    parser.add_argument(
        '-d', '--6s-dir',
        dest='sixs_dir',
        default='./fortran/',
        help='Directory to output Fortran files. Defaults to "./fortran/"'
    )

    args = parser.parse_args()
    
    if not os.path.isdir(args.sixs_dir):
        parser.error(f'{args.sixs_dir} is not a valid directory or does not exist.')
        
    if not args.f_files and not args.recursive_dir:
        parser.error('Must either provide list of .f files or a directory with -r. Use -h for more info.')
    
    if args.f_files and args.recursive_dir:
        print('Both file list and directory are provided. Ignoring the directory and only using provided .f files.')
        
    f_files = []
    if args.f_files:
        # Get all the generated fortran file paths
        for f_name in args.f_files:
            if f_name[-2:] != '.f':
                parser.error(f'{f_name} does not end with .f.')
            # if filename has no path, assume in sixs_dir
            # otherwise copy it into sixs_dir
            f_basename = os.path.basename(f_name)
            target_path = os.path.join(args.sixs_dir, f_basename)
            if not args.override and os.path.exists(target_path):
                parser.error(f'{target_path} already exists. Set the -o flag to override it. ONLY DO SO IF IT IS A USER-GENERATED .f FILE.')
            if not f_basename == f_name or os.path.exists(f_basename): 
                print(f'Copying {f_basename} into {args.sixs_dir}')
                shutil.copyfile(f_name, target_path)
            f_files.append(target_path)
            
            if not os.path.exists(target_path):
                parser.error(f'{target_path} does not exist.')
    else:
        if args.recursive_dir == args.sixs_dir:
            parser.error('Directory to read .f files from cannot be the same as the 6S code directory.')
            
        for filename in os.scandir(args.recursive_dir):
            if filename.is_file():
                target_path = os.path.join(args.sixs_dir, filename.name)
                if not args.override and os.path.exists(target_path):
                    parser.error(f'{target_path} already exists. Set the -o flag to override it. ONLY DO SO IF IT IS A USER-GENERATED .f FILE.')
            
                print(f'Copying {filename.path} into {args.sixs_dir}')
                shutil.copyfile(filename.path, target_path)
                f_files.append(target_path)
        
    print('Attempting to edit Makefile and main.f of 6S code to include newly generated .f file.')
    
    makefile_path = os.path.join(args.sixs_dir, 'Makefile')
    if not os.path.exists(makefile_path) or not os.path.isfile(makefile_path):
        parser.error(f'{makefile_path} is not a path or does not exist.')
        
    with open(makefile_path, 'r') as f:
        mf_lines = f.readlines()
        extra_obj_line_index = -1
        sixs_build_start_line_index = -1
        for i, line in enumerate(mf_lines):
            if line.startswith('OBJECTSEXTRA='):
                extra_obj_line_index = i
            elif line.startswith('sixs:'):
                sixs_build_start_line_index = i
                
        if sixs_build_start_line_index == -1:
            raise Exception(f'{makefile_path} is not a valid Makefile. ' + \
                'Build instructions for target sixs does not exist. ' + \
                'Are you sure you downloaded the correct 6S code (6SV2+)?')
                
        print(mf_lines[extra_obj_line_index], mf_lines[sixs_build_start_line_index])
            
        extra_build_objs = [os.path.basename(path).split('.')[0] + '.o' for path in f_files]
        extra_build_objs_str = 'OBJECTSEXTRA= ' + (' '.join(extra_build_objs)) + '\n'
        
        if extra_obj_line_index == -1:
            mf_lines.insert(sixs_build_start_line_index, extra_build_objs_str)
            mf_lines.insert(sixs_build_start_line_index + 1, '\n')
            sixs_build_start_line_index += 2
        else:
            mf_lines[extra_obj_line_index] = extra_build_objs_str
            
        try:
            mf_lines[sixs_build_start_line_index].index('$(OBJECTSEXTRA)')
        except ValueError:
            mf_lines[sixs_build_start_line_index] = f'{mf_lines[sixs_build_start_line_index][:-1]} $(OBJECTSEXTRA)\n'
            
        try:
            mf_lines[sixs_build_start_line_index+1].index('$(OBJECTSEXTRA)')
        except ValueError:
            before_o, after_o = mf_lines[sixs_build_start_line_index+1].split('-o')
            mf_lines[sixs_build_start_line_index+1] = f'{before_o}$(OBJECTSEXTRA) -o{after_o}'
            
        try:
            mf_lines[sixs_build_start_line_index+2].index('$(OBJECTSEXTRA)')
        except ValueError:
            before_o, after_o = mf_lines[sixs_build_start_line_index+2].split('-o')
            mf_lines[sixs_build_start_line_index+2] = f'{before_o}$(OBJECTSEXTRA) -o{after_o}'
            
    with open(makefile_path, 'w') as f:
        f.write(''.join(mf_lines))
        print('Successfully wrote Makefile.')
        
    